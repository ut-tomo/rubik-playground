<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik & Group Theory Playground</title>
    <meta name="description" content="WebAssembly + Three.jsで作られたインタラクティブなルービックキューブシミュレーターで群論を学ぼう">
    <link rel="stylesheet" href="style.css">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script>
        window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
        };
    </script>
</head>
<body>
    <!-- ヘッダー -->
    <header class="site-header">
        <div class="header-content">
            <h1 class="site-title">Rubik & Group Theory Playground</h1>
        </div>
        <nav class="site-nav">
            <a href="#about">About</a>
            <a href="#demo">Demo</a>
        </nav>
    </header>

    <!-- メインコンテンツ -->
    <main class="main-content">
        <!-- About セクション -->
        <section id="about" class="content-section">
            <div class="section-inner">
                <h2>About</h2>
                <p>
                    このPlaygroundは, シングマスター記法に基づく直感的なルービックキューブ操作を提供します:
                </p>
                <h3>
                    シングマスター記法:
                </h3>
                    <p style="margin-left: 20px;">
                    $U: $上面を時計回りに90度回転 (Up)<br>
                    $D: $下面を時計回りに90度回転 (Down)<br>
                    $L: $左面を時計回りに90度回転 (Left)<br>
                    $R: $右面を時計回りに90度回転 (Right)<br>
                    $F: $前面を時計回りに90度回転 (Front)<br>
                    $B: $背面を時計回りに90度回転 (Back)<br>
                    <p>
                    ただし, 上面は黄色, 下面は白色, 左面は青色, 右面は緑色, 前面は赤色, 背面は橙色で固定されています。また, 時計回りはそれぞれの面に向かい合った際の方向を指します。
                </p>
                <p>
                    頂点やエッジのキューブについてもu, d, l, r, f, bをそれぞれの面に対応させて同様の規則性で表現されます。例えばufrと書くと, 上面・前面・右面の3つの面が交わる頂点キューブを指すので, ここでは黄赤緑色を持つキューブを指します。
                </p>
                <p>
                また, 各記号の後に'(アポストロフィ)をつけることはその逆操作をすることを示し, 2をつけることはその操作を2回連続して行う, つまり$180$度回転を行うことを意味します。
                </p>
                <p>
                    Quick Movesのセクションのボタンはこれらの基本操作を適用するものです。また, Algorithmセクションではこれらの記法を用いて連続した操作を行うことができます。ただし, 書き込む際は各スペースの間に半角スペースを入れてください。
                </p>
            </div>
        </section>
        <!-- Features セクション -->

        <!-- Demo セクション -->
        <section id="demo" class="content-section demo-section">
            <div class="section-inner">
                <h2>群論 $\times$ ルービックキューブ</h2>
                <p class="features">
                    シングマスター記法およびこのPlaygroundの直感的な操作の助けを借りて, 群論的な観点の理解を助けます。
                    また, この内容の作成にあたり「群論の味わい 置換群で解き明かすルービックキューブと15パズル」(David Joyner著, 川辺治之訳 共立出版)および
                    「群論への第一歩 集合, 写像から準同型定理まで」(結城浩著 SB Creative) を参考にしています。
                </p>
            </div>
        </section>

        <br>
        <section id="demo" class="content-section demo-section">
            <div class="section-inner">
                <h2>Try It Out</h2>
                <p>
                    下のキューブを操作してみてみましょう！
                </p>
                <p>
                    参考までに, よく知られたルービックキューブの操作と対応するシングマスター記法を示します。Copy & Paste して試してみてください。
                </p>
                <div>
                    <p>・セクシームーブ <span class="notation-snippet">R U R' U'</span></p>
                    <p>・右トリガー (右回転) <span class="notation-snippet">U R U' R'</span></p>
                </div>
                <p>
                    これらをそれぞれ6回連続で適用すると元に戻ることを確認してみてください !
                    後で触れますが, このような部分的な交換を行うことを目的とした操作は Commutator (A→B→A'→B')という形でも表現できます。
                </p>
                    
            </div>
        </section>
    
    <div id="loading">
        <h1>Loading Rubik's Cube Playground...</h1>
        <p id="loading-status">Initializing...</p>
        <div style="margin-top: 20px;">
            <div style="width: 300px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                <div id="progress-bar" style="width: 0%; height: 100%; background: white; transition: width 0.3s;"></div>
            </div>
        </div>
    </div>

    <div id="app">
        <div id="canvas-container"></div>
        
        <div id="controls">
            <h1>遊んでみよう</h1>
            
            <div id="status">
                <strong>Status:</strong> <span id="solved-status">Solved ✓</span>
            </div>

            <h2>Quick Moves</h2>
            <div class="move-buttons">
                <button onclick="applyMove('U')">U</button>
                <button onclick="applyMove('U2')">U2</button>
                <button onclick="applyMove('U\'')">U'</button>
                <button onclick="applyMove('D')">D</button>
                <button onclick="applyMove('D2')">D2</button>
                <button onclick="applyMove('D\'')">D'</button>
                <button onclick="applyMove('L')">L</button>
                <button onclick="applyMove('L2')">L2</button>
                <button onclick="applyMove('L\'')">L'</button>
                <button onclick="applyMove('R')">R</button>
                <button onclick="applyMove('R2')">R2</button>
                <button onclick="applyMove('R\'')">R'</button>
                <button onclick="applyMove('F')">F</button>
                <button onclick="applyMove('F2')">F2</button>
                <button onclick="applyMove('F\'')">F'</button>
                <button onclick="applyMove('B')">B</button>
                <button onclick="applyMove('B2')">B2</button>
                <button onclick="applyMove('B\'')">B'</button>
            </div>

            <h2>Algorithm</h2>
            <div class="input-group">
                <input type="text" id="algorithm-input" placeholder="例: R U R' U'" />
                <div class="action-buttons">
                    <button onclick="applyAlgorithm()">Apply</button>
                    <button onclick="showInverse()">Inverse</button>
                    <button onclick="resetCube()">Reset</button>
                </div>
            </div>

            <h2>Advanced</h2>
            <div class="input-group">
                <input type="text" id="alg-a" placeholder="Algorithm A" />
                <input type="text" id="alg-b" placeholder="Algorithm B" />
                <div class="action-buttons">
                    <button onclick="applyCommutator()">Commutator</button>
                    <button onclick="applyConjugate()">Conjugate</button>
                </div>
            </div>

            <h2>Info</h2>
            <div class="info-section">
                <div id="state-info" style="font-size: 1em;">State: ...</div>
            </div>
        </div>
    </div>
        <section id="demo" class="content-section demo-section">
            <div class="section-inner">
                <h2>1. 操作の数学的記述</h2>
                <details class="collapsible">
                    <summary>1-1. 構造の基本表現</summary>
                    <div class="collapsible-content">
                        <p class="gt1-1">
                            ルービックキューブ操作のモデル化は個々の小立方体の位置と向きを表現することによります。このPlaygroundでもそのように実装されています。
                            Info部分にはその状態が記述されています。
                        </p>
                        <p>
                            まず $3\times3\times3$ ルービックキューブは27個の小立方体から構成されています。
                            キューブは観察されず, また6面それぞれの中心に存在するキューブはあらゆる操作に対して位置関係が変化せず, 固定しても操作の一般性を失わないため群構造からは除外されます。<br>
                            よって残りのキューブを特徴づければ良いことになります。これらはさらに2種類に分類できます。
                        </p>
                        <p>
                            一つは立方体の頂点位置に存在する8個のコーナーキューブであり, これは State 部分で corner_perm, および corner_ori という表現がされていますが, 
                            位置と拗れ具合により特徴づけられます。(あるコーナーにあるキューブと拗れ具合の情報があれば, その部分の3面の色が定まるということです。このPlaygroundでも構造体がキューブの位置と向きを保持し, そこから色を割り出しています。)<br>
                            また拗れ具合は3値による表現がされますが, これは物理キューブを持っている方は実際に(ねじれないタイプのやつもあると思いますが)ねじってみると3パターンあるとわかります。
                        </p>
                        <p>
                            もう一つは立方体の辺の中央に存在する12個のエッジキューブであり, これは edge_perm, および edge_ori という表現がされています。
                            こちらのorientationは裏表の2値であることはわかりやすいでしょう。
                        </p>
                    </div>
                </details>
                <details class="collapsible">
                    <summary>1-2. 操作と写像</summary>
                    <div class="collapsible-content">
                        <p class="gt1-2">
                            ルービックキューブは小立方体の集合としてみなせるのでした。そして, ルービックキューブに施されるあらゆる操作はこれらの小立方体集合上の全単射として記述できます。
                            操作は確かにあるキューブを別の場所に移動させ, キューブが欠落する部分もないですし, 各元に対してちょうど一つの像を対応させますから, ほぼ自明でこれ自体はなんてことないように思えます。
                            しかしこれが操作が置換として記述できることを保証してくれ, 群論的な議論の土台を提供してくれます。このおかげで, 合成や位数, 逆操作などを厳密に扱えます。
                        </p>
                </details>
                <details class="collapsible">
                    <summary>1-3. 群の定義</summary>
                    <div class="collapsible-content">
                        <p class="gt1-3">
                            群は以下のようなものとして定義されます:
                        </p>
                        <p>
                            ある集合 $G$ と, $G$ 上の二項演算 $*$ が与えられ, 次の3つの性質を満たすとき, $(G, *)$ を群と呼ぶ:
                        </p>
                        <p>
                            1. (結合律) 任意の $a, b, c \in G$ に対して, $(a * b) * c = a * (b * c)$ が成り立つ。<br>
                            2. (単位元の存在) $G$ に属するある元 $e$ が存在して, 任意の $a \in G$ に対して, $e * a = a * e = a$ が成り立つ。<br>
                            3. (逆元の存在) 任意の $a \in G$ に対して, ある元 $b \in G$ が存在して, $a * b = b * a = e$ が成り立つ。<br>
                        </p>
                        <p>
                            これら3つの性質を群の公理と呼びます。
                        </p>
                </details>

            </div>
        </section>
        <br>
        <section id="demo" class="content-section demo-section">
            <div class="section-inner">
                <h2>2. 置換群</h2>
                <details class="collapsible">
                    <summary>2-1. 置換</summary>
                    <div class="collapsible-content">
                        <p>
                            $\mathbb{Z}_n$ の置換とは, $\mathbb{Z}_n$ からそれ自身への全単射のことです。しばしば $n$ 次置換とも呼ばれます。
                            1, 2, 3を順番に並べる順列と3次置換は一対一に対応します。<br>
                        </p>
                        <p>
                            $n$ 次置換全体の集合を $S_n$ と表すとき, 写像の合成を $\circ$ とすると, $(S_n, \circ)$ は群を成します。これを $n$ 次対称群と呼び, $n$ 次対称群の部分群を置換群と呼びます。
                            あらゆる操作は置換として記述出来ますから, 適切な位置・向きの操作を伴う置換の設計により perm 構造体をハンドルできるわけです。
                        </p>
                    </div>
                </details>
                <details class="collapsible">
                    <summary>2-2. 巡回置換</summary>
                    <div class="collapsible-content">
                        <p>
                            次に, 巡回置換(巡換)と呼ばれるものについて考えます。巡回置換とは, ある部分集合の元を互いに循環的に入れ替え, それ以外の元は不動にするような置換のことです。
                            置換 $\sigma$ を $\sigma = (a_1\ a_2\ \cdots\ a_k)$ と表すとき, これは $a_1$ を $a_2$ に, $a_2$ を $a_3$ に, $\ldots$, $a_{k-1}$ を $a_k$ に, $a_k$ を $a_1$ に移す置換を意味します。
                            これは $k$ 巡換と呼ばれ, 任意の置換は巡換の積として一意的に表現できることが知られています。
                        </p>
                        <p>
                            置換が偶置換 (= 偶数個の2巡換の積で表現できる) か奇置換 (= 奇数個の2巡換の積で表現できる) のどちらかであることはよく知られている重要な性質です。
                            そして, ルービックキューブにおける合法操作は偶置換に対応することも知られています。これは, コーナーキューブ, エッジキューブともにの $90$ 度回転は $4$-cycle, つまり奇置換であり, どの面回転もコーナーとエッジが同時に奇置換となって全体としては偶置換になることなどからわかります。
                            これは, Parity 制約という置換の偶奇が等しいことを要求する制約条件としてルービックキューブ群の最も基本的かつ重要な物理的制約の一つとなります。
                        </p>

                    </div>
                </details>
                <details class="collapsible">
                    <summary>2-3. 置換に関する有名補題</summary>
                    <div class="collapsible-content">
                        <p>
                            ルービックキューブをうまく解く人は, 以下の補題を暗黙のうちに何度も使っているようです。
                        </p>
                        <p>
                            補題: $r \in S_n$ を置換とし, $i$ および $j$ を $\{1, 2, \ldots, n\}$ の互いに異なる元とする。$s$ を, $i$ を $j$ に写す置換, すなわち
                            \[
                                s(i) = j
                            \]
                            とするとき, 置換 $s^r = r^{-1}sr$ は $r(i)$ を $r(j)$ に写す置換である。すなわち,
                            \[
                                s^r(r(i)) = r(j)
                            \]
                            が成り立つ。
                        </p>
                        <p>
                            特に, $i_1, i_2, \ldots, i_k$ を $\{1, 2, \ldots, n\}$ の互いに異なる元とし, 
                            $s$ を $i_j$ を $i_{j+1}$ に写す巡回置換とするとき,置換 $s^r = r^{-1}sr$ は $r(i_j)$ を 
                            $r(i_{j+1})$ に写す巡回置換である。
                        </p>
                        <p>
                            これをルービックキューブにおいて実際に体験してみます。
                        </p>
                        <p>
                            顕著な例が, <span class="notation-snippet">R' D2 R B' U2 B</span></p>を2回繰り返す操作で, これはurfを時計回りに, bldを反時計回りにひねります。実際に上で試してみてください。
                        </p>
                        <p>
                            基本的には R による操作と Bによる操作を考えれば事足りるというのが補題の主張になります。
                            \[
                            r = \begin{bmatrix} 1 & 2 & 5 & 6 \\ r(1) & r(2) & r(5) & r(6) \end{bmatrix} = \begin{bmatrix} 1 & 2 & 5 & 6 \\ 5 & 1 & 6 & 2 \end{bmatrix}
                            \]
                        </p>
                        <p>
                            R' D2 Rなどの細かい操作列で区切って実行したりなどしながら上のような形で表される変換のことなどをなんとなく想像すると, 
                            気持ちが想像できるのではないでしょうか。
                        </p>
                        <p>
                            明確にはこの補題は証明しませんが, 要は「基本のねじり置換を, キューブの対称性（セットアップムーブ）で共役した結果」というわけです。
                            このような, 共役と言われる, ある操作 $m_1$ を行なって, $m_2$ を行い, さらに $m_1$ の逆操作を行うという形の操作ルービックキューブの操作では頻出です。
                        </p>
                    </div>
                </details>
                <br>
        <section id="demo" class="content-section demo-section">
                <h2>3. 交換子 (Commutator)</h2>
                <details class="collapsible">
                    <summary>3-1. 交換子</summary>
                        <div class="collapsible-content">
                            <p>
                                ルービックキューブの操作はすべて置換として記述できるため, 群論でいう
                                コミュテーター (commutator) の概念が極めて重要になります。
                                操作列 $A, B$ に対し, コミュテーターとは
                                \[
                                    [A, B] = A B A^{-1} B^{-1}
                                \]
                                と定義され, これは $A$ と $B$ の非可換性を抽出するための操作です。
                                $A$ と $B$ が可換であれば $[A, B]$ は恒等変換となりますが, 可換でない場合には
                                一部のキューブ片だけを動かす「局所的な変化」が生じます。
                            </p>

                <p>
                    この「局所的な変化」は, ルービックキューブにおける特定のピースだけの入れ替え, 
                    すなわち巡回置換 (cycle) を構成する際に非常に有用です。
                    多くの場合, コミュテーターはコーナーやエッジの
                    3-cycle を自然に生み出します。
                    実際, $A$ で対象ピースを取り出し, $B$ でその取り出された空間で交換を行い, 
                    $A^{-1}$ で元に戻し, $B^{-1}$ で全体の整合性を保つことにより, 
                    $A$ によって動く範囲にのみ交換が閉じるからです。
                </p>

                <p>
                    典型例として, 以下のような操作がエッジの3-cycleを引き起こします。
                    \[
                        [A, B] = (R U R') (U R U')
                    \]
                    これは, $A = R U R'$, $B = U R U'$ としたときのコミュテーターであり, 
                    3つのエッジピースが循環的に入れ替わります。
                    実際には, このような「$A$ で持ち上げて $B$ でかき混ぜる」という構造によって, 
                    特定の部分だけが動き, その他の部分は不動に保たれます。
                </p>

                <p>
                    なお, コミュテーターと密接に関連する概念として共役 (conjugation) があります。
                    これは, 前節でも述べたように, ある操作 $m_1$ を行い, 次に $m_2$ を行い, 
                    最後に $m_1^{-1}$ を行う形の操作であり, 
                    \[
                        m_2^{m_1} = m_1^{-1} m_2 m_1
                    \]
                    と表されます。コミュテーターはまさに共役の差分を抽出する操作でもあり, 
                    ルービックキューブのアルゴリズム設計においては
                    「基本的なねじり操作をセットアップムーブで好きな位置に移す」ための
                    基本手法として頻繁に登場します。
                </p>

                <p>
                    このように, コミュテーターは「キューブの特定の部分だけを動かす」
                    という強力な性質を持ち, 特にFMC (Fewest Move Challenge) や
                    高度な手順構築において必須の道具となります。
                    実際に小さな操作列を分解して, その効果がどのピースに閉じているかを追うと, 
                    コミュテーターが生み出すサイクル構造を体感できるでしょう。
                </p>
                </div>
                </details>
                <details class="collapsible">
                    <summary>3-2. 交換子の例</summary>
                    <div class="collapsible-content">
                        <p>
                            例えば, 先ほど紹介したセクシームーブ $R U R' U'$ は, 
                            3つのエッジキューブを循環的に入れ替える3-cycleを生成します。
                            これは, $A = R U R'$ と $B = U$ としたときのコミュテーター $[A, B]$ に対応します。
                        </p>
                        <p>
                            実際にこの操作を試してみると, 3つのエッジキューブが互いに位置を交換し,
                            他のキューブは不動であることが確認できます。
                            このように, コミュテーターは特定のピースだけを動かす強力な手法として,
                            ルービックキューブのアルゴリズム設計において頻繁に利用されます。
                        </p>
                    </div>          
                </details>
            </div>
        </section>
        
        </section>

    </main>

    <footer class="site-footer">
        <p class="tech-stack-label">Powered by</p>
        <div class="tech-stack">
            <span>Rust</span>
            <span>WebAssembly</span>
            <span>Three.js</span>
        </div>
    </footer>

    <script type="module">
        import { main } from './cube-app.js';
        main();
    </script>
</body>
</html>
