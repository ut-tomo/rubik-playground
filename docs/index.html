<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§Š Rubik's Cube Playground</title>
    <meta name="description" content="WebAssembly + Three.jsã§ä½œã‚‰ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼">
    <link rel="stylesheet" href="style.css">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
    <header class="site-header">
        <div class="header-content">
            <h1 class="site-title">ğŸ§Š Rubik's Cube Playground</h1>
            <p class="site-subtitle">Rust + WebAssembly ã§å‹•ãã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–</p>
        </div>
        <nav class="site-nav">
            <a href="#about">About</a>
            <a href="#features">Features</a>
            <a href="#demo">Demo</a>
            <a href="https://github.com/ut-tomo/rubik-playground" target="_blank">GitHub</a>
        </nav>
    </header>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    <main class="main-content">
        <!-- About ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <section id="about" class="content-section">
            <div class="section-inner">
                <h2>About</h2>
                <p>
                    ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Rustã§å®Ÿè£…ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’
                    WebAssemblyã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€Three.jsã‚’ä½¿ç”¨ã—ã¦3Dãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿç¾ã—ãŸã‚‚ã®ã§ã™ã€‚
                </p>
                <p>
                    ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æ“ä½œã§ãã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å‹•ãã‚’è¦–è¦šçš„ã«ç¢ºèªã§ãã¾ã™ã€‚
                </p>
            </div>
        </section>

        <!-- Features ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <section id="features" class="content-section">
            <div class="section-inner">
                <h2>Features</h2>
                <ul class="feature-list">
                    <li>
                        <strong>ğŸ¦€ Rust + WebAssembly</strong>
                        <p>é«˜é€Ÿã‹ã¤å®‰å…¨ãªã‚­ãƒ¥ãƒ¼ãƒ–ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…</p>
                    </li>
                    <li>
                        <strong>ğŸ¨ 3D Visualization</strong>
                        <p>Three.jsã«ã‚ˆã‚‹ç¾ã—ã„3Dãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°</p>
                    </li>
                    <li>
                        <strong>ğŸ® Interactive Controls</strong>
                        <p>ç›´æ„Ÿçš„ãªæ“ä½œã¨æ‰‹ã®å…¥åŠ›ã«å¯¾å¿œ</p>
                    </li>
                    <li>
                        <strong>ğŸ“ Algorithm Support</strong>
                        <p>æ¨™æº–çš„ãªã‚­ãƒ¥ãƒ¼ãƒ–è¨˜æ³•ï¼ˆR, U, F, etc.ï¼‰ã‚’ã‚µãƒãƒ¼ãƒˆ</p>
                    </li>
                </ul>
            </div>
        </section>

        <!-- Demo ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <section id="demo" class="content-section demo-section">
            <div class="section-inner">
                <h2>Try It Out</h2>
                <p class="demo-description">
                    ä¸‹ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æ“ä½œã—ã¦ã¿ã¦ãã ã•ã„ã€‚ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã‹ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å…¥åŠ›ã§ãã¾ã™ã€‚
                </p>
            </div>
        </section>
    </main>
    
    <div id="loading">
        <h1>ğŸ§Š Loading Rubik's Cube Playground...</h1>
        <p id="loading-status">Initializing...</p>
        <div style="margin-top: 20px;">
            <div style="width: 300px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                <div id="progress-bar" style="width: 0%; height: 100%; background: white; transition: width 0.3s;"></div>
            </div>
        </div>
    </div>

    <div id="app">
        <div id="canvas-container"></div>
        
        <div id="controls">
            <h1>éŠã‚“ã§ã¿ã‚ˆã†</h1>
            
            <div id="status">
                <strong>Status:</strong> <span id="solved-status">Solved âœ“</span>
            </div>

            <h2>Quick Moves</h2>
            <div class="move-buttons">
                <button onclick="applyMove('U')">U</button>
                <button onclick="applyMove('U2')">U2</button>
                <button onclick="applyMove('U\'')">U'</button>
                <button onclick="applyMove('D')">D</button>
                <button onclick="applyMove('D2')">D2</button>
                <button onclick="applyMove('D\'')">D'</button>
                <button onclick="applyMove('L')">L</button>
                <button onclick="applyMove('L2')">L2</button>
                <button onclick="applyMove('L\'')">L'</button>
                <button onclick="applyMove('R')">R</button>
                <button onclick="applyMove('R2')">R2</button>
                <button onclick="applyMove('R\'')">R'</button>
                <button onclick="applyMove('F')">F</button>
                <button onclick="applyMove('F2')">F2</button>
                <button onclick="applyMove('F\'')">F'</button>
                <button onclick="applyMove('B')">B</button>
                <button onclick="applyMove('B2')">B2</button>
                <button onclick="applyMove('B\'')">B'</button>
            </div>

            <h2>Algorithm</h2>
            <div class="input-group">
                <input type="text" id="algorithm-input" placeholder="ä¾‹: R U R' U'" />
                <div class="action-buttons">
                    <button onclick="applyAlgorithm()">Apply</button>
                    <button onclick="showInverse()">Inverse</button>
                    <button onclick="resetCube()">Reset</button>
                </div>
            </div>

            <h2>Advanced</h2>
            <div class="input-group">
                <input type="text" id="alg-a" placeholder="Algorithm A" />
                <input type="text" id="alg-b" placeholder="Algorithm B" />
                <div class="action-buttons">
                    <button onclick="applyCommutator()">Commutator</button>
                    <button onclick="applyConjugate()">Conjugate</button>
                </div>
            </div>

            <h2>Info</h2>
            <div class="info-section">
                <div id="state-info" style="font-size: 1em;">State: ...</div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Three.js is now loaded, start immediately
        console.log('Three.js loaded, starting initialization...');

        // Global variables
        let cube;
        let scene, camera, renderer, controls;
        let cubeGroup;
        let wasmModule;

        async function main() {
            try {
                const startTime = performance.now();
                
                updateProgress(10, 'Loading WASM module...');
                console.log('Loading WASM module...');
                const wasmStart = performance.now();
                wasmModule = await import('./pkg/cube_wasm.js');
                console.log(`WASM module loaded in ${(performance.now() - wasmStart).toFixed(0)}ms`);
                
                updateProgress(40, 'Initializing WASM...');
                console.log('Initializing WASM...');
                const initStart = performance.now();
                await wasmModule.default();
                console.log(`WASM initialized in ${(performance.now() - initStart).toFixed(0)}ms`);
                
                updateProgress(60, 'Setting up scene...');
                console.log('Creating cube and scene...');
                const sceneStart = performance.now();
                
                // Three.js is already loaded via import at top
                updateProgress(80, 'Creating visualization...');
                initApp();
                console.log(`Scene setup in ${(performance.now() - sceneStart).toFixed(0)}ms`);
                
                updateProgress(100, 'Ready!');
                console.log(`Total initialization time: ${(performance.now() - startTime).toFixed(0)}ms`);
                
                // Hide loading and show app
                document.getElementById('loading').style.display = 'none';
                document.getElementById('app').style.display = 'grid';
                
                // Wait for layout to complete, then resize renderer
                setTimeout(() => {
                    const container = document.getElementById('canvas-container');
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    console.log('Container size after layout:', width, 'x', height);
                    
                    if (width > 0 && height > 0) {
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        console.log('Renderer resized to:', width, 'x', height);
                    }
                }, 50);
                
            } catch (error) {
                console.error('Error during initialization:', error);
                document.getElementById('loading').innerHTML = `
                    <h2>âŒ Error Loading</h2>
                    <p>${error.message}</p>
                `;
            }
        }

        function updateProgress(percent, status) {
            document.getElementById('progress-bar').style.width = percent + '%';
            document.getElementById('loading-status').textContent = status;
        }

        function initApp() {
            // Create cube
            cube = new wasmModule.WasmCube();
            window.cube = cube;
            window.wasmModule = wasmModule;

            // Setup Three.js scene
            setupScene();

            // Create initial visualization
            updateVisualization();

            // Start animation loop
            startAnimation();

            console.log('App initialized successfully!');
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera - use temporary aspect ratio, will be corrected after layout
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer - start with minimum size, will be resized after layout
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(100, 100);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            console.log('Initial renderer size: 100x100 (will be resized after layout)');

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 10, 5);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            // Window resize
            window.addEventListener('resize', () => {
                const container = document.getElementById('canvas-container');
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            console.log('Scene setup complete');
        }

        // Corner positions: [x, y, z]
        // Corner index mapping (must match cube-core/src/state.rs)
        // 0: UFL, 1: UFR, 2: UBR, 3: UBL, 4: DFL, 5: DFR, 6: DBR, 7: DBL
        const CORNER_POSITIONS = [
            { pos: [-1, 1, 1] },   // 0: UFL
            { pos: [1, 1, 1] },    // 1: UFR
            { pos: [1, 1, -1] },   // 2: UBR
            { pos: [-1, 1, -1] },  // 3: UBL
            { pos: [-1, -1, 1] },  // 4: DFL
            { pos: [1, -1, 1] },   // 5: DFR
            { pos: [1, -1, -1] },  // 6: DBR
            { pos: [-1, -1, -1] }, // 7: DBL
        ];

        // Corner piece base colors: [U/Dé¢ã®è‰², ç¬¬2ã®è‰², ç¬¬3ã®è‰²]
        // å„ãƒ”ãƒ¼ã‚¹ã®3è‰²ã‚’å®šç¾©ï¼ˆåˆæœŸä½ç½®ã§ã®è‰²é…ç½®ï¼‰
        // perm 0-7ã«å¯¾å¿œ
        // è‰²ID: 0=é»„(U), 1=ç™½(D), 2=é’(L), 3=ç·‘(R), 4=èµ¤(F), 5=æ©™(B)
        const CORNER_BASE_COLORS = [
            [0, 2, 4],  // 0: UFL (é»„ãƒ»é’ãƒ»èµ¤) - ä¸Š=é»„, å·¦=é’, å‰=èµ¤
            [0, 4, 3],  // 1: UFR (é»„ãƒ»èµ¤ãƒ»ç·‘) - ä¸Š=é»„, å‰=èµ¤, å³=ç·‘
            [0, 3, 5],  // 2: UBR (é»„ãƒ»ç·‘ãƒ»æ©™) - ä¸Š=é»„, å³=ç·‘, å¾Œ=æ©™
            [0, 5, 2],  // 3: UBL (é»„ãƒ»æ©™ãƒ»é’) - ä¸Š=é»„, å¾Œ=æ©™, å·¦=é’
            [1, 4, 2],  // 4: DFL (ç™½ãƒ»èµ¤ãƒ»é’) - ä¸‹=ç™½, å‰=èµ¤, å·¦=é’
            [1, 3, 4],  // 5: DFR (ç™½ãƒ»ç·‘ãƒ»èµ¤) - ä¸‹=ç™½, å³=ç·‘, å‰=èµ¤
            [1, 5, 3],  // 6: DBR (ç™½ãƒ»æ©™ãƒ»ç·‘) - ä¸‹=ç™½, å¾Œ=æ©™, å³=ç·‘
            [1, 2, 5]   // 7: DBL (ç™½ãƒ»é’ãƒ»æ©™) - ä¸‹=ç™½, å·¦=é’, å¾Œ=æ©™
        ];

        // Position definitions: ã©ã®é¢ãŒè¦‹ãˆã‚‹ã‹
        // å„ä½ç½®ã§ã®é¢ã®å‰²ã‚Šå½“ã¦ [Yè»¸é¢, side1, side2]
        // Yè»¸é¢: top(ä¸Šæ®µ) or bottom(ä¸‹æ®µ)
        // side1, side2: ä½ç½®ã«å¿œã˜ãŸå´é¢
        const CORNER_POSITION_INFO = [
            { yFace: 'top', side1: 'left', side2: 'front' },   // 0: UFL
            { yFace: 'top', side1: 'front', side2: 'right' },  // 1: UFR
            { yFace: 'top', side1: 'right', side2: 'back' },   // 2: UBR
            { yFace: 'top', side1: 'back', side2: 'left' },    // 3: UBL
            { yFace: 'bottom', side1: 'front', side2: 'left' }, // 4: DFL
            { yFace: 'bottom', side1: 'right', side2: 'front' },// 5: DFR
            { yFace: 'bottom', side1: 'back', side2: 'right' }, // 6: DBR
            { yFace: 'bottom', side1: 'left', side2: 'back' }   // 7: DBL
        ];


        // Edge positions: [x, y, z] and their sticker faces [face1, face2]
        // Edge index mapping (must match cube-core/src/state.rs)
        // 0: UF, 1: UR, 2: UB, 3: UL, 4: FL, 5: FR, 6: BR, 7: BL, 8: DF, 9: DR, 10: DB, 11: DL
        // faces ã®é †åºã¯ã€U/Dé¢ã®ã‚¨ãƒƒã‚¸ã¯[ä¸Šä¸‹é¢, å´é¢]ã€ä¸­æ®µã®ã‚¨ãƒƒã‚¸ã¯[å‰å¾Œé¢, å·¦å³é¢]
        const EDGE_POSITIONS = [
            { pos: [0, 1, 1], faces: [0, 4] },    // 0: UF (Up-Front)
            { pos: [1, 1, 0], faces: [0, 3] },    // 1: UR (Up-Right)
            { pos: [0, 1, -1], faces: [0, 5] },   // 2: UB (Up-Back)
            { pos: [-1, 1, 0], faces: [0, 2] },   // 3: UL (Up-Left)
            { pos: [-1, 0, 1], faces: [4, 2] },   // 4: FL (Front-Left)
            { pos: [1, 0, 1], faces: [4, 3] },    // 5: FR (Front-Right)
            { pos: [1, 0, -1], faces: [5, 3] },   // 6: BR (Back-Right)
            { pos: [-1, 0, -1], faces: [5, 2] },  // 7: BL (Back-Left)
            { pos: [0, -1, 1], faces: [1, 4] },   // 8: DF (Down-Front)
            { pos: [1, -1, 0], faces: [1, 3] },   // 9: DR (Down-Right)
            { pos: [0, -1, -1], faces: [1, 5] },  // 10: DB (Down-Back)
            { pos: [-1, -1, 0], faces: [1, 2] },  // 11: DL (Down-Left)
        ];

        // Get colors for a corner piece based on state
        // ä¸€èˆ¬çš„ãªå®Ÿè£…: åŸºæœ¬è‰² + position + orientation ã‹ã‚‰å‹•çš„ã«è¨ˆç®—
        function getCornerColors(cornerIndex, state) {
            const perm = state.corner_perm[cornerIndex];
            const ori = state.corner_ori[cornerIndex];
            
            // ãƒ”ãƒ¼ã‚¹ã®åŸºæœ¬3è‰²ã‚’å–å¾— [Yè»¸è‰², Aè‰², Bè‰²]
            const baseColors = CORNER_BASE_COLORS[perm];
            
            // orientation ã«ã‚ˆã‚‹è‰²ã®å›è»¢ã‚’é©ç”¨
            // ori=0: ãã®ã¾ã¾ [Y, A, B]
            // ori=1: Yè»¸å‘¨ã‚Šã«120Â°å›è»¢ [A, B, Y]
            // ori=2: Yè»¸å‘¨ã‚Šã«240Â°å›è»¢ [B, Y, A]
            let rotatedColors;
            if (ori === 0) {
                rotatedColors = [baseColors[0], baseColors[1], baseColors[2]];
            } else if (ori === 1) {
                rotatedColors = [baseColors[1], baseColors[2], baseColors[0]];
            } else { // ori === 2
                rotatedColors = [baseColors[2], baseColors[0], baseColors[1]];
            }
            
            // ä½ç½®æƒ…å ±ã‚’å–å¾—
            const posInfo = CORNER_POSITION_INFO[cornerIndex];
            
            // çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
            const result = {
                top: -1,
                bottom: -1,
                left: -1,
                right: -1,
                front: -1,
                back: -1
            };
            
            // Yè»¸é¢ã«è‰²ã‚’é…ç½®
            result[posInfo.yFace] = rotatedColors[0];
            
            // side1 ã«è‰²ã‚’é…ç½®
            result[posInfo.side1] = rotatedColors[1];
            
            // side2 ã«è‰²ã‚’é…ç½®
            result[posInfo.side2] = rotatedColors[2];
            
            return result;

        }

        // Get colors for an edge piece based on state
        // Returns an object with colors for each face: {right, left, top, bottom, front, back}
        // è‰²IDã‚’è¿”ã™ï¼ˆ0-5ã®æ•°å€¤ã€ã¾ãŸã¯é»’ã®å ´åˆã¯-1ï¼‰
        function getEdgeColors(edgeIndex, state) {
            const perm = state.edge_perm[edgeIndex];   // ã©ã®ã‚¨ãƒƒã‚¸ãŒã“ã®ä½ç½®ã«ã‚ã‚‹ã‹
            const ori = state.edge_ori[edgeIndex];      // å‘ã (0 or 1)
            
            // ã“ã®ä½ç½®ã®ã‚¨ãƒƒã‚¸ãŒæŒã¤ã¹ã2è‰²ï¼ˆå…ƒã®è‰²ï¼‰
            const originalFaces = EDGE_POSITIONS[perm].faces;
            
            // oriãŒ1ãªã‚‰åè»¢
            const [color1, color2] = ori === 1 ? 
                [originalFaces[1], originalFaces[0]] : 
                [originalFaces[0], originalFaces[1]];
            
            const result = {
                right: -1,
                left: -1,
                top: -1,
                bottom: -1,
                front: -1,
                back: -1
            };
            
            // æ˜ç¤ºçš„ãªãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆä½ç½®ã”ã¨ã«å®šç¾©ï¼‰
            // Rustå´ã®å®šç¾©: 0: UF, 1: UR, 2: UB, 3: UL, 4: FL, 5: FR, 6: BR, 7: BL, 8: DF, 9: DR, 10: DB, 11: DL
            if (edgeIndex === 0) { // UF: ä¸Šã¨å‰
                result.top = color1;
                result.front = color2;
            } else if (edgeIndex === 1) { // UR: ä¸Šã¨å³
                result.top = color1;
                result.right = color2;
            } else if (edgeIndex === 2) { // UB: ä¸Šã¨å¥¥
                result.top = color1;
                result.back = color2;
            } else if (edgeIndex === 3) { // UL: ä¸Šã¨å·¦
                result.top = color1;
                result.left = color2;
            } else if (edgeIndex === 4) { // FL: å‰ã¨å·¦
                result.front = color1;
                result.left = color2;
            } else if (edgeIndex === 5) { // FR: å‰ã¨å³
                result.front = color1;
                result.right = color2;
            } else if (edgeIndex === 6) { // BR: å¥¥ã¨å³
                result.back = color1;
                result.right = color2;
            } else if (edgeIndex === 7) { // BL: å¥¥ã¨å·¦
                result.back = color1;
                result.left = color2;
            } else if (edgeIndex === 8) { // DF: ä¸‹ã¨å‰
                result.bottom = color1;
                result.front = color2;
            } else if (edgeIndex === 9) { // DR: ä¸‹ã¨å³
                result.bottom = color1;
                result.right = color2;
            } else if (edgeIndex === 10) { // DB: ä¸‹ã¨å¥¥
                result.bottom = color1;
                result.back = color2;
            } else if (edgeIndex === 11) { // DL: ä¸‹ã¨å·¦
                result.bottom = color1;
                result.left = color2;
            }
            
            return result;
        }

        function createCubeVisualization(state) {
            console.log('Creating cube visualization...');
            
            // Remove old cube group if exists
            if (cubeGroup) {
                scene.remove(cubeGroup);
                // Dispose of geometries and materials to free memory
                cubeGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                cubeGroup = null;
            }
            
            cubeGroup = new THREE.Group();
            
            const cubeSize = 0.9;
            const gap = 0.05;
            const colorMap = {
                0: 0xffff00, // Yellow (U - ä¸Šé¢)
                1: 0xffffff, // White (D - ä¸‹é¢)
                2: 0x2130E7, // Blue (L - å·¦é¢)
                3: 0x00ff00, // Green (R - å³é¢)
                4: 0xff0000, // Red (F - å‰é¢) - ã‚ˆã‚Šé®®æ˜
                5: 0xffac51, // Orange (B - å¥¥é¢) - ã‚ˆã‚Šé®®ã‚„ã‹ã«
            };
            
            // State is passed as parameter
            console.log('Creating visualization with state:', state);
            console.log('  corner_perm:', state.corner_perm);
            console.log('  corner_ori:', state.corner_ori);
            console.log('  edge_perm:', state.edge_perm);
            console.log('  edge_ori:', state.edge_ori);
            
            // Create corner pieces (8 corners)
            for (let i = 0; i < 8; i++) {
                const cornerDef = CORNER_POSITIONS[i];
                const [x, y, z] = cornerDef.pos;
                const colors = getCornerColors(i, state);
                
                const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                
                // Materials for 6 faces: [Right, Left, Top, Bottom, Front, Back]
                const materials = [
                    new THREE.MeshStandardMaterial({ color: colors.right >= 0 ? colorMap[colors.right] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.left >= 0 ? colorMap[colors.left] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.top >= 0 ? colorMap[colors.top] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.bottom >= 0 ? colorMap[colors.bottom] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.front >= 0 ? colorMap[colors.front] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.back >= 0 ? colorMap[colors.back] : 0x000000 }),
                ];
                
                const cubelet = new THREE.Mesh(geometry, materials);
                cubelet.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
                
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                cubelet.add(line);
                cubeGroup.add(cubelet);
            }
            
            // Create edge pieces (12 edges)
            for (let i = 0; i < 12; i++) {
                const edgeDef = EDGE_POSITIONS[i];
                const [x, y, z] = edgeDef.pos;
                const colors = getEdgeColors(i, state);
                
                const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                
                // æ˜ç¤ºçš„ã«å„é¢ã®è‰²ã‚’å–å¾—
                const materials = [
                    new THREE.MeshStandardMaterial({ color: colors.right >= 0 ? colorMap[colors.right] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.left >= 0 ? colorMap[colors.left] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.top >= 0 ? colorMap[colors.top] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.bottom >= 0 ? colorMap[colors.bottom] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.front >= 0 ? colorMap[colors.front] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: colors.back >= 0 ? colorMap[colors.back] : 0x000000 }),
                ];
                
                const cubelet = new THREE.Mesh(geometry, materials);
                cubelet.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
                
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                cubelet.add(line);
                cubeGroup.add(cubelet);
            }
            
            // Create center pieces (6 centers - fixed)
            const centers = [
                { pos: [1, 0, 0], color: 3 },   // Right - Green
                { pos: [-1, 0, 0], color: 2 },  // Left - Blue
                { pos: [0, 1, 0], color: 0 },   // Top - Yellow
                { pos: [0, -1, 0], color: 1 },  // Bottom - White
                { pos: [0, 0, 1], color: 4 },   // Front - Red
                { pos: [0, 0, -1], color: 5 },  // Back - Orange
            ];
            
            for (const center of centers) {
                const [x, y, z] = center.pos;
                const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                
                const materials = [
                    new THREE.MeshStandardMaterial({ color: x === 1 ? colorMap[center.color] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: x === -1 ? colorMap[center.color] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: y === 1 ? colorMap[center.color] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: y === -1 ? colorMap[center.color] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: z === 1 ? colorMap[center.color] : 0x000000 }),
                    new THREE.MeshStandardMaterial({ color: z === -1 ? colorMap[center.color] : 0x000000 }),
                ];
                
                const cubelet = new THREE.Mesh(geometry, materials);
                cubelet.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
                
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                cubelet.add(line);
                cubeGroup.add(cubelet);
            }
            
            scene.add(cubeGroup);
            console.log('Cube visualization created, pieces:', cubeGroup.children.length);
            console.log('CubeGroup added to scene. Scene children:', scene.children.length);
        }

        function updateVisualization() {
            // Get current state and pass to visualization
            const state = cube.getState();
            createCubeVisualization(state);
            
            // Update status
            const isSolved = cube.isSolved();
            const statusEl = document.getElementById('status');
            const solvedStatus = document.getElementById('solved-status');
            
            if (isSolved) {
                statusEl.classList.add('solved');
                solvedStatus.textContent = 'Solved âœ“';
            } else {
                statusEl.classList.remove('solved');
                solvedStatus.textContent = 'Scrambled';
            }
            
            // Update state info - show detailed arrays
            // state is already obtained above
            console.log('Detailed state:');
            console.log('  corner_perm:', state.corner_perm);
            console.log('  corner_ori:', state.corner_ori);
            console.log('  edge_perm:', state.edge_perm);
            console.log('  edge_ori:', state.edge_ori);
            
            document.getElementById('state-info').innerHTML = `
                <strong>State:</strong><br>
                <small>
                corner_perm: [${state.corner_perm.join(', ')}]<br>
                corner_ori: [${state.corner_ori.join(', ')}]<br>
                edge_perm: [${state.edge_perm.join(', ')}]<br>
                edge_ori: [${state.edge_ori.join(', ')}]
                </small>
            `;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        let animationStarted = false;
        function startAnimation() {
            if (!animationStarted) {
                animationStarted = true;
                console.log('Animation loop started');
                animate();
            }
        }

        // Global functions
        window.applyMove = function(moveStr) {
            try {
                console.log('Applying move:', moveStr);
                
                // Store old rotation for animation
                const oldRotation = cubeGroup.rotation.y;
                
                cube.applyMove(moveStr);
                updateVisualization();
                
                // Add rotation animation for visual feedback
                const rotationAmount = 0.2; // radians
                cubeGroup.rotation.y = oldRotation + rotationAmount;
                
                // Animate back to original rotation
                const startRotation = cubeGroup.rotation.y;
                const targetRotation = oldRotation;
                const duration = 200; // ms
                const startTime = performance.now();
                
                function animateRotation() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                    
                    cubeGroup.rotation.y = startRotation + (targetRotation - startRotation) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateRotation);
                    }
                }
                animateRotation();
                
            } catch (e) {
                console.error('Error applying move:', e);
                alert('Error: ' + e);
            }
        };

        window.applyAlgorithm = function() {
            const alg = document.getElementById('algorithm-input').value;
            if (!alg) return;
            
            try {
                console.log('Applying algorithm:', alg);
                cube.applyAlgorithm(alg);
                updateVisualization();
            } catch (e) {
                console.error('Error applying algorithm:', e);
                alert('Error: ' + e);
            }
        };

        window.showInverse = function() {
            const alg = document.getElementById('algorithm-input').value;
            if (!alg) return;
            
            try {
                const inv = wasmModule.invertAlgorithm(alg);
                document.getElementById('algorithm-input').value = inv;
            } catch (e) {
                console.error('Error calculating inverse:', e);
                alert('Error: ' + e);
            }
        };

        window.resetCube = function() {
            console.log('Resetting cube');
            cube = new wasmModule.WasmCube();
            window.cube = cube;
            updateVisualization();
        };

        window.applyCommutator = function() {
            const a = document.getElementById('alg-a').value;
            const b = document.getElementById('alg-b').value;
            if (!a || !b) {
                alert('Please enter both algorithms');
                return;
            }
            
            try {
                const result = wasmModule.commutator(a, b);
                document.getElementById('algorithm-input').value = result;
                cube.applyAlgorithm(result);
                updateVisualization();
            } catch (e) {
                console.error('Error applying commutator:', e);
                alert('Error: ' + e);
            }
        };

        window.applyConjugate = function() {
            const a = document.getElementById('alg-a').value;
            const b = document.getElementById('alg-b').value;
            if (!a || !b) {
                alert('Please enter both algorithms');
                return;
            }
            
            try {
                const result = wasmModule.conjugate(a, b);
                document.getElementById('algorithm-input').value = result;
                cube.applyAlgorithm(result);
                updateVisualization();
            } catch (e) {
                console.error('Error applying conjugate:', e);
                alert('Error: ' + e);
            }
        };

        main();
    </script>
</body>
</html>
